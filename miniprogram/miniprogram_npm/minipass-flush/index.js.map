{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["const Minipass = require('minipass')\nconst _flush = Symbol('_flush')\nconst _flushed = Symbol('_flushed')\nconst _flushing = Symbol('_flushing')\nclass Flush extends Minipass {\n  constructor (opt = {}) {\n    if (typeof opt === 'function')\n      opt = { flush: opt }\n\n    super(opt)\n\n    // or extend this class and provide a 'flush' method in your subclass\n    if (typeof opt.flush !== 'function' && typeof this.flush !== 'function')\n      throw new TypeError('must provide flush function in options')\n\n    this[_flush] = opt.flush || this.flush\n  }\n\n  emit (ev, ...data) {\n    if ((ev !== 'end' && ev !== 'finish') || this[_flushed])\n      return super.emit(ev, ...data)\n\n    if (this[_flushing])\n      return\n\n    this[_flushing] = true\n\n    const afterFlush = er => {\n      this[_flushed] = true\n      er ? super.emit('error', er) : super.emit('end')\n    }\n\n    const ret = this[_flush](afterFlush)\n    if (ret && ret.then)\n      ret.then(() => afterFlush(), er => afterFlush(er))\n  }\n}\n\nmodule.exports = Flush\n"]}