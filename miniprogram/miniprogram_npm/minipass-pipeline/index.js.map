{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["const Minipass = require('minipass')\nconst EE = require('events')\nconst isStream = s => s && s instanceof EE && (\n  typeof s.pipe === 'function' || // readable\n  (typeof s.write === 'function' && typeof s.end === 'function') // writable\n)\n\nconst _head = Symbol('_head')\nconst _tail = Symbol('_tail')\nconst _linkStreams = Symbol('_linkStreams')\nconst _setHead = Symbol('_setHead')\nconst _setTail = Symbol('_setTail')\nconst _onError = Symbol('_onError')\nconst _onData = Symbol('_onData')\nconst _onEnd = Symbol('_onEnd')\nconst _onDrain = Symbol('_onDrain')\nconst _streams = Symbol('_streams')\nclass Pipeline extends Minipass {\n  constructor (opts, ...streams) {\n    if (isStream(opts)) {\n      streams.unshift(opts)\n      opts = {}\n    }\n\n    super(opts)\n    this[_streams] = []\n    if (streams.length)\n      this.push(...streams)\n  }\n\n  [_linkStreams] (streams) {\n    // reduce takes (left,right), and we return right to make it the\n    // new left value.\n    return streams.reduce((src, dest) => {\n      src.on('error', er => dest.emit('error', er))\n      src.pipe(dest)\n      return dest\n    })\n  }\n\n  push (...streams) {\n    this[_streams].push(...streams)\n    if (this[_tail])\n      streams.unshift(this[_tail])\n\n    const linkRet = this[_linkStreams](streams)\n\n    this[_setTail](linkRet)\n    if (!this[_head])\n      this[_setHead](streams[0])\n  }\n\n  unshift (...streams) {\n    this[_streams].unshift(...streams)\n    if (this[_head])\n      streams.push(this[_head])\n\n    const linkRet = this[_linkStreams](streams)\n    this[_setHead](streams[0])\n    if (!this[_tail])\n      this[_setTail](linkRet)\n  }\n\n  destroy (er) {\n    // set fire to the whole thing.\n    this[_streams].forEach(s =>\n      typeof s.destroy === 'function' && s.destroy())\n    return super.destroy(er)\n  }\n\n  // readable interface -> tail\n  [_setTail] (stream) {\n    this[_tail] = stream\n    stream.on('error', er => this[_onError](stream, er))\n    stream.on('data', chunk => this[_onData](stream, chunk))\n    stream.on('end', () => this[_onEnd](stream))\n    stream.on('finish', () => this[_onEnd](stream))\n  }\n\n  // errors proxied down the pipeline\n  // they're considered part of the \"read\" interface\n  [_onError] (stream, er) {\n    if (stream === this[_tail])\n      this.emit('error', er)\n  }\n  [_onData] (stream, chunk) {\n    if (stream === this[_tail])\n      super.write(chunk)\n  }\n  [_onEnd] (stream) {\n    if (stream === this[_tail])\n      super.end()\n  }\n  pause () {\n    super.pause()\n    return this[_tail] && this[_tail].pause && this[_tail].pause()\n  }\n\n  // NB: Minipass calls its internal private [RESUME] method during\n  // pipe drains, to avoid hazards where stream.resume() is overridden.\n  // Thus, we need to listen to the resume *event*, not override the\n  // resume() method, and proxy *that* to the tail.\n  emit (ev, ...args) {\n    if (ev === 'resume' && this[_tail] && this[_tail].resume)\n      this[_tail].resume()\n    return super.emit(ev, ...args)\n  }\n\n  // writable interface -> head\n  [_setHead] (stream) {\n    this[_head] = stream\n    stream.on('drain', () => this[_onDrain](stream))\n  }\n  [_onDrain] (stream) {\n    if (stream === this[_head])\n      this.emit('drain')\n  }\n  write (chunk, enc, cb) {\n    return this[_head].write(chunk, enc, cb) &&\n      (this.flowing || this.buffer.length === 0)\n  }\n  end (chunk, enc, cb) {\n    this[_head].end(chunk, enc, cb)\n    return this\n  }\n}\n\nmodule.exports = Pipeline\n"]}