{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["const Minipass = require('minipass')\n\nclass SizeError extends Error {\n  constructor (found, expect) {\n    super(`Bad data size: expected ${expect} bytes, but got ${found}`)\n    this.expect = expect\n    this.found = found\n    this.code = 'EBADSIZE'\n\t  Error.captureStackTrace(this, this.constructor)\n  }\n  get name () {\n    return 'SizeError'\n  }\n}\n\nclass MinipassSized extends Minipass {\n  constructor (options = {}) {\n    super(options)\n\n    if (options.objectMode)\n      throw new TypeError(`${\n        this.constructor.name\n      } streams only work with string and buffer data`)\n\n    this.found = 0\n    this.expect = options.size\n    if (typeof this.expect !== 'number' ||\n        this.expect > Number.MAX_SAFE_INTEGER ||\n        isNaN(this.expect) ||\n        this.expect < 0 ||\n        !isFinite(this.expect) ||\n        this.expect !== Math.floor(this.expect))\n      throw new Error('invalid expected size: ' + this.expect)\n  }\n\n  write (chunk, encoding, cb) {\n    const buffer = Buffer.isBuffer(chunk) ? chunk\n      : typeof chunk === 'string' ?\n        Buffer.from(chunk, typeof encoding === 'string' ? encoding : 'utf8')\n      : chunk\n\n    if (!Buffer.isBuffer(buffer)) {\n      this.emit('error', new TypeError(`${\n        this.constructor.name\n      } streams only work with string and buffer data`))\n      return false\n    }\n\n    this.found += buffer.length\n    if (this.found > this.expect)\n      this.emit('error', new SizeError(this.found, this.expect))\n\n    return super.write(chunk, encoding, cb)\n  }\n\n  emit (ev, ...data) {\n    if (ev === 'end') {\n      if (this.found !== this.expect)\n        this.emit('error', new SizeError(this.found, this.expect))\n    }\n    return super.emit(ev, ...data)\n  }\n}\n\nMinipassSized.SizeError = SizeError\n\nmodule.exports = MinipassSized\n"]}