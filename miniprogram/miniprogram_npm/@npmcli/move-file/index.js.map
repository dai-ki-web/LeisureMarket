{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["const { dirname, join, resolve, relative, isAbsolute } = require('path')\nconst rimraf_ = require('rimraf')\nconst { promisify } = require('util')\nconst {\n  access: access_,\n  accessSync,\n  copyFile: copyFile_,\n  copyFileSync,\n  unlink: unlink_,\n  unlinkSync,\n  readdir: readdir_,\n  readdirSync,\n  rename: rename_,\n  renameSync,\n  stat: stat_,\n  statSync,\n  lstat: lstat_,\n  lstatSync,\n  symlink: symlink_,\n  symlinkSync,\n  readlink: readlink_,\n  readlinkSync\n} = require('fs')\n\nconst access = promisify(access_)\nconst copyFile = promisify(copyFile_)\nconst unlink = promisify(unlink_)\nconst readdir = promisify(readdir_)\nconst rename = promisify(rename_)\nconst stat = promisify(stat_)\nconst lstat = promisify(lstat_)\nconst symlink = promisify(symlink_)\nconst readlink = promisify(readlink_)\nconst rimraf = promisify(rimraf_)\nconst rimrafSync = rimraf_.sync\n\nconst mkdirp = require('mkdirp')\n\nconst pathExists = async path => {\n  try {\n    await access(path)\n    return true\n  } catch (er) {\n    return er.code !== 'ENOENT'\n  }\n}\n\nconst pathExistsSync = path => {\n  try {\n    accessSync(path)\n    return true\n  } catch (er) {\n    return er.code !== 'ENOENT'\n  }\n}\n\nconst moveFile = async (source, destination, options = {}, root = true, symlinks = []) => {\n  if (!source || !destination) {\n    throw new TypeError('`source` and `destination` file required')\n  }\n\n  options = {\n    overwrite: true,\n    ...options\n  }\n\n  if (!options.overwrite && await pathExists(destination)) {\n    throw new Error(`The destination file exists: ${destination}`)\n  }\n\n  await mkdirp(dirname(destination))\n\n  try {\n    await rename(source, destination)\n  } catch (error) {\n    if (error.code === 'EXDEV' || error.code === 'EPERM') {\n      const sourceStat = await lstat(source)\n      if (sourceStat.isDirectory()) {\n        const files = await readdir(source)\n        await Promise.all(files.map((file) => moveFile(join(source, file), join(destination, file), options, false, symlinks)))\n      } else if (sourceStat.isSymbolicLink()) {\n        symlinks.push({ source, destination })\n      } else {\n        await copyFile(source, destination)\n      }\n    } else {\n      throw error\n    }\n  }\n\n  if (root) {\n    await Promise.all(symlinks.map(async ({ source, destination }) => {\n      let target = await readlink(source)\n      // junction symlinks in windows will be absolute paths, so we need to make sure they point to the destination\n      if (isAbsolute(target))\n        target = resolve(destination, relative(source, target))\n      // try to determine what the actual file is so we can create the correct type of symlink in windows\n      let targetStat\n      try {\n        targetStat = await stat(resolve(dirname(source), target))\n      } catch (err) {}\n      await symlink(target, destination, targetStat && targetStat.isDirectory() ? 'junction' : 'file')\n    }))\n    await rimraf(source)\n  }\n}\n\nconst moveFileSync = (source, destination, options = {}, root = true, symlinks = []) => {\n  if (!source || !destination) {\n    throw new TypeError('`source` and `destination` file required')\n  }\n\n  options = {\n    overwrite: true,\n    ...options\n  }\n\n  if (!options.overwrite && pathExistsSync(destination)) {\n    throw new Error(`The destination file exists: ${destination}`)\n  }\n\n  mkdirp.sync(dirname(destination))\n\n  try {\n    renameSync(source, destination)\n  } catch (error) {\n    if (error.code === 'EXDEV' || error.code === 'EPERM') {\n      const sourceStat = lstatSync(source)\n      if (sourceStat.isDirectory()) {\n        const files = readdirSync(source)\n        for (const file of files) {\n          moveFileSync(join(source, file), join(destination, file), options, false, symlinks)\n        }\n      } else if (sourceStat.isSymbolicLink()) {\n        symlinks.push({ source, destination })\n      } else {\n        copyFileSync(source, destination)\n      }\n    } else {\n      throw error\n    }\n  }\n\n  if (root) {\n    for (const { source, destination } of symlinks) {\n      let target = readlinkSync(source)\n      // junction symlinks in windows will be absolute paths, so we need to make sure they point to the destination\n      if (isAbsolute(target))\n        target = resolve(destination, relative(source, target))\n      // try to determine what the actual file is so we can create the correct type of symlink in windows\n      let targetStat\n      try {\n        targetStat = statSync(resolve(dirname(source), target))\n      } catch (err) {}\n      symlinkSync(target, destination, targetStat && targetStat.isDirectory() ? 'junction' : 'file')\n    }\n    rimrafSync(source)\n  }\n}\n\nmodule.exports = moveFile\nmodule.exports.sync = moveFileSync\n"]}