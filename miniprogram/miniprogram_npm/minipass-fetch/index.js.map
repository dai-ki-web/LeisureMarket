{"version":3,"sources":["index.js","body.js","blob.js","fetch-error.js","response.js","headers.js","request.js","../package.json","abort-error.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,AENA,AHSA;AELA,ADGA,AENA,AHSA;AELA,ADGA,AENA,AHSA;AELA,ADGA,AENA,AHSA,AIZA;AFOA,ADGA,AENA,AHSA,AIZA;AFOA,ADGA,AENA,AHSA,AIZA;AFOA,ADGA,AENA,AENA,ALeA,AIZA;AFOA,ADGA,AENA,AENA,ALeA,AIZA;AFOA,ADGA,AENA,AENA,ALeA,AIZA;AFOA,ADGA,AENA,AENA,ALeA,AMlBA,AFMA;AFOA,ADGA,AENA,AENA,ALeA,AMlBA,AFMA;AFOA,ADGA,AENA,AENA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AENA,AENA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AENA,AENA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AENA,AENA,ALeA,AMlBA,AFMA;AGRA,ACHA,ANkBA,ADGA,AENA,AENA,ALeA,AMlBA,AFMA;AGRA,ACHA,ANkBA,ADGA,AENA,AENA,ALeA,AMlBA,AFMA;AGRA,ACHA,ANkBA,ADGA,AENA,AENA,ALeA,AMlBA,AFMA;AGRA,ACHA,ANkBA,ADGA,AENA,AENA,ALeA,AMlBA,AFMA;AGRA,ACHA,ANkBA,ADGA,AENA,AENA,ALeA,AMlBA,AFMA;AGRA,ACHA,ANkBA,ADGA,AENA,AENA,ALeA,AMlBA,AFMA;AGRA,ACHA,ANkBA,ADGA,AENA,AENA,ALeA,AMlBA,AFMA;AGRA,ACHA,ANkBA,ADGA,AENA,AENA,ALeA,AMlBA,AFMA;AGRA,ACHA,ANkBA,ADGA,AENA,AENA,ALeA,AMlBA,AFMA;AGRA,ACHA,ANkBA,ADGA,AENA,AENA,ALeA,AMlBA,AFMA;AGRA,ACHA,ANkBA,ADGA,AENA,AENA,ALeA,AMlBA,AFMA;AGRA,ACHA,ANkBA,ADGA,AENA,AENA,ALeA,AMlBA,AFMA;AGRA,ACHA,ANkBA,ADGA,AENA,AENA,ALeA,AMlBA,AFMA;AGRA,ACHA,ANkBA,ADGA,AENA,AENA,ALeA,AMlBA,AFMA;AGRA,ACHA,ANkBA,ADGA,AENA,AENA,ALeA,AMlBA,AFMA;AGRA,ACHA,ANkBA,ADGA,AENA,AENA,ALeA,AMlBA,AFMA;AGRA,ACHA,ANkBA,ADGA,AENA,AENA,ALeA,AMlBA,AFMA;AGRA,ACHA,ANkBA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA,AFMA;AGRA,ALeA,ADGA,AIZA,ALeA,AMlBA;ACFA,ALeA,ADGA,AIZA,ALeA,AMlBA;ACFA,ANkBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,AIZA,ALeA,AMlBA;ALgBA,ADGA,AMlBA;ALgBA,ADGA,AMlBA;ALgBA,ADGA,AMlBA;ALgBA,ADGA,AMlBA;ALgBA,ADGA,AMlBA;ALgBA,ADGA,AMlBA;ALgBA,ADGA,AMlBA;ALgBA,ADGA,AMlBA;ALgBA,ADGA,AMlBA;ALgBA,ADGA,AMlBA;ALgBA,ADGA,AMlBA;ALgBA,ADGA,AMlBA;ALgBA,ADGA,AMlBA;ALgBA,ADGA,AMlBA;ALgBA,ADGA,AMlBA;ALgBA,ADGA,AMlBA;ALgBA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\nconst Url = require('url')\nconst http = require('http')\nconst https = require('https')\nconst zlib = require('minizlib')\nconst Minipass = require('minipass')\n\nconst Body = require('./body.js')\nconst { writeToStream, getTotalBytes } = Body\nconst Response = require('./response.js')\nconst Headers = require('./headers.js')\nconst { createHeadersLenient } = Headers\nconst Request = require('./request.js')\nconst { getNodeRequestOptions } = Request\nconst FetchError = require('./fetch-error.js')\nconst AbortError = require('./abort-error.js')\n\nconst resolveUrl = Url.resolve\n\nconst fetch = (url, opts) => {\n  if (/^data:/.test(url)) {\n    const request = new Request(url, opts)\n    try {\n      const split = url.split(',')\n      const data = Buffer.from(split[1], 'base64')\n      const type = split[0].match(/^data:(.*);base64$/)[1]\n      return Promise.resolve(new Response(data, {\n        headers: {\n          'Content-Type': type,\n          'Content-Length': data.length,\n        }\n      }))\n    } catch (er) {\n      return Promise.reject(new FetchError(`[${request.method}] ${\n        request.url} invalid URL, ${er.message}`, 'system', er))\n    }\n  }\n\n  return new Promise((resolve, reject) => {\n    // build request object\n    const request = new Request(url, opts)\n    let options\n    try {\n      options = getNodeRequestOptions(request)\n    } catch (er) {\n      return reject(er)\n    }\n\n    const send = (options.protocol === 'https:' ? https : http).request\n    const { signal } = request\n    let response = null\n    const abort = () => {\n      const error = new AbortError('The user aborted a request.')\n      reject(error)\n      if (Minipass.isStream(request.body) &&\n          typeof request.body.destroy === 'function') {\n        request.body.destroy(error)\n      }\n      if (response && response.body) {\n        response.body.emit('error', error)\n      }\n    }\n\n    if (signal && signal.aborted)\n      return abort()\n\n    const abortAndFinalize = () => {\n      abort()\n      finalize()\n    }\n\n    const finalize = () => {\n      req.abort()\n      if (signal)\n        signal.removeEventListener('abort', abortAndFinalize)\n      clearTimeout(reqTimeout)\n    }\n\n    // send request\n    const req = send(options)\n\n    if (signal)\n      signal.addEventListener('abort', abortAndFinalize)\n\n    let reqTimeout = null\n    if (request.timeout) {\n      req.once('socket', socket => {\n        reqTimeout = setTimeout(() => {\n          reject(new FetchError(`network timeout at: ${\n            request.url}`, 'request-timeout'))\n          finalize()\n        }, request.timeout)\n      })\n    }\n\n    req.on('error', er => {\n      // if a 'response' event is emitted before the 'error' event, then by the\n      // time this handler is run it's too late to reject the Promise for the\n      // response. instead, we forward the error event to the response stream\n      // so that the error will surface to the user when they try to consume\n      // the body. this is done as a side effect of aborting the request except\n      // for in windows, where we must forward the event manually, otherwise\n      // there is no longer a ref'd socket attached to the request and the\n      // stream never ends so the event loop runs out of work and the process\n      // exits without warning.\n      // coverage skipped here due to the difficulty in testing\n      // istanbul ignore next\n      if (req.res)\n        req.res.emit('error', er)\n      reject(new FetchError(`request to ${request.url} failed, reason: ${\n        er.message}`, 'system', er))\n      finalize()\n    })\n\n    req.on('response', res => {\n      clearTimeout(reqTimeout)\n\n      const headers = createHeadersLenient(res.headers)\n\n      // HTTP fetch step 5\n      if (fetch.isRedirect(res.statusCode)) {\n        // HTTP fetch step 5.2\n        const location = headers.get('Location')\n\n        // HTTP fetch step 5.3\n        const locationURL = location === null ? null\n          : resolveUrl(request.url, location)\n\n        // HTTP fetch step 5.5\n        switch (request.redirect) {\n          case 'error':\n            reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${\n              request.url}`, 'no-redirect'))\n            finalize()\n            return\n\n          case 'manual':\n            // node-fetch-specific step: make manual redirect a bit easier to\n            // use by setting the Location header value to the resolved URL.\n            if (locationURL !== null) {\n              // handle corrupted header\n              try {\n                headers.set('Location', locationURL)\n              } catch (err) {\n                /* istanbul ignore next: nodejs server prevent invalid\n                   response headers, we can't test this through normal\n                   request */\n                reject(err)\n              }\n            }\n            break\n\n          case 'follow':\n            // HTTP-redirect fetch step 2\n            if (locationURL === null) {\n              break\n            }\n\n            // HTTP-redirect fetch step 5\n            if (request.counter >= request.follow) {\n              reject(new FetchError(`maximum redirect reached at: ${\n                request.url}`, 'max-redirect'))\n              finalize()\n              return\n            }\n\n            // HTTP-redirect fetch step 9\n            if (res.statusCode !== 303 &&\n                request.body &&\n                getTotalBytes(request) === null) {\n              reject(new FetchError(\n                'Cannot follow redirect with body being a readable stream',\n                'unsupported-redirect'\n              ))\n              finalize()\n              return\n            }\n\n            // Update host due to redirection\n            request.headers.set('host', Url.parse(locationURL).host)\n\n            // HTTP-redirect fetch step 6 (counter increment)\n            // Create a new Request object.\n            const requestOpts = {\n              headers: new Headers(request.headers),\n              follow: request.follow,\n              counter: request.counter + 1,\n              agent: request.agent,\n              compress: request.compress,\n              method: request.method,\n              body: request.body,\n              signal: request.signal,\n              timeout: request.timeout,\n            }\n\n            // HTTP-redirect fetch step 11\n            if (res.statusCode === 303 || (\n                (res.statusCode === 301 || res.statusCode === 302) &&\n                request.method === 'POST'\n            )) {\n              requestOpts.method = 'GET'\n              requestOpts.body = undefined\n              requestOpts.headers.delete('content-length')\n            }\n\n            // HTTP-redirect fetch step 15\n            resolve(fetch(new Request(locationURL, requestOpts)))\n            finalize()\n            return\n        }\n      } // end if(isRedirect)\n\n\n      // prepare response\n      res.once('end', () =>\n        signal && signal.removeEventListener('abort', abortAndFinalize))\n\n      const body = new Minipass()\n      // exceedingly rare that the stream would have an error,\n      // but just in case we proxy it to the stream in use.\n      res.on('error', /* istanbul ignore next */ er => body.emit('error', er))\n      res.on('data', (chunk) => body.write(chunk))\n      res.on('end', () => body.end())\n\n      const responseOptions = {\n        url: request.url,\n        status: res.statusCode,\n        statusText: res.statusMessage,\n        headers: headers,\n        size: request.size,\n        timeout: request.timeout,\n        counter: request.counter,\n        trailer: new Promise(resolve =>\n          res.on('end', () => resolve(createHeadersLenient(res.trailers))))\n      }\n\n      // HTTP-network fetch step 12.1.1.3\n      const codings = headers.get('Content-Encoding')\n\n      // HTTP-network fetch step 12.1.1.4: handle content codings\n\n      // in following scenarios we ignore compression support\n      // 1. compression support is disabled\n      // 2. HEAD request\n      // 3. no Content-Encoding header\n      // 4. no content response (204)\n      // 5. content not modified response (304)\n      if (!request.compress ||\n          request.method === 'HEAD' ||\n          codings === null ||\n          res.statusCode === 204 ||\n          res.statusCode === 304) {\n        response = new Response(body, responseOptions)\n        resolve(response)\n        return\n      }\n\n\n      // Be less strict when decoding compressed responses, since sometimes\n      // servers send slightly invalid responses that are still accepted\n      // by common browsers.\n      // Always using Z_SYNC_FLUSH is what cURL does.\n      const zlibOptions = {\n        flush: zlib.constants.Z_SYNC_FLUSH,\n        finishFlush: zlib.constants.Z_SYNC_FLUSH,\n      }\n\n      // for gzip\n      if (codings == 'gzip' || codings == 'x-gzip') {\n        const unzip = new zlib.Gunzip(zlibOptions)\n        response = new Response(\n          // exceedingly rare that the stream would have an error,\n          // but just in case we proxy it to the stream in use.\n          body.on('error', /* istanbul ignore next */ er => unzip.emit('error', er)).pipe(unzip),\n          responseOptions\n        )\n        resolve(response)\n        return\n      }\n\n      // for deflate\n      if (codings == 'deflate' || codings == 'x-deflate') {\n        // handle the infamous raw deflate response from old servers\n        // a hack for old IIS and Apache servers\n        const raw = res.pipe(new Minipass())\n        raw.once('data', chunk => {\n          // see http://stackoverflow.com/questions/37519828\n          const decoder = (chunk[0] & 0x0F) === 0x08\n            ? new zlib.Inflate()\n            : new zlib.InflateRaw()\n          // exceedingly rare that the stream would have an error,\n          // but just in case we proxy it to the stream in use.\n          body.on('error', /* istanbul ignore next */ er => decoder.emit('error', er)).pipe(decoder)\n          response = new Response(decoder, responseOptions)\n          resolve(response)\n        })\n        return\n      }\n\n\n      // for br\n      if (codings == 'br') {\n        // ignoring coverage so tests don't have to fake support (or lack of) for brotli\n        // istanbul ignore next\n        try {\n          var decoder = new zlib.BrotliDecompress()\n        } catch (err) {\n          reject(err)\n          finalize()\n          return\n        }\n        // exceedingly rare that the stream would have an error,\n        // but just in case we proxy it to the stream in use.\n        body.on('error', /* istanbul ignore next */ er => decoder.emit('error', er)).pipe(decoder)\n        response = new Response(decoder, responseOptions)\n        resolve(response)\n        return\n      }\n\n      // otherwise, use response as-is\n      response = new Response(body, responseOptions)\n      resolve(response)\n    })\n\n    writeToStream(req, request)\n  })\n}\n\nmodule.exports = fetch\n\nfetch.isRedirect = code =>\n  code === 301 ||\n  code === 302 ||\n  code === 303 ||\n  code === 307 ||\n  code === 308\n\nfetch.Headers = Headers\nfetch.Request = Request\nfetch.Response = Response\nfetch.FetchError = FetchError\n","\nconst Minipass = require('minipass')\nconst MinipassSized = require('minipass-sized')\n\nconst Blob = require('./blob.js')\nconst {BUFFER} = Blob\nconst FetchError = require('./fetch-error.js')\n\n// optional dependency on 'encoding'\nlet convert\ntry {\n  convert = require('encoding').convert\n} catch (e) {}\n\nconst INTERNALS = Symbol('Body internals')\nconst CONSUME_BODY = Symbol('consumeBody')\n\nclass Body {\n  constructor (bodyArg, options = {}) {\n    const { size = 0, timeout = 0 } = options\n    const body = bodyArg === undefined || bodyArg === null ? null\n      : isURLSearchParams(bodyArg) ? Buffer.from(bodyArg.toString())\n      : isBlob(bodyArg) ? bodyArg\n      : Buffer.isBuffer(bodyArg) ? bodyArg\n      : Object.prototype.toString.call(bodyArg) === '[object ArrayBuffer]'\n        ? Buffer.from(bodyArg)\n      : ArrayBuffer.isView(bodyArg)\n        ? Buffer.from(bodyArg.buffer, bodyArg.byteOffset, bodyArg.byteLength)\n      : Minipass.isStream(bodyArg) ? bodyArg\n      : Buffer.from(String(bodyArg))\n\n    this[INTERNALS] = {\n      body,\n      disturbed: false,\n      error: null,\n    }\n\n    this.size = size\n    this.timeout = timeout\n\n    if (Minipass.isStream(body)) {\n      body.on('error', er => {\n        const error = er.name === 'AbortError' ? er\n          : new FetchError(`Invalid response while trying to fetch ${\n            this.url}: ${er.message}`, 'system', er)\n        this[INTERNALS].error = error\n      })\n    }\n  }\n\n  get body () {\n    return this[INTERNALS].body\n  }\n\n  get bodyUsed () {\n    return this[INTERNALS].disturbed\n  }\n\n  arrayBuffer () {\n    return this[CONSUME_BODY]().then(buf =>\n      buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength))\n  }\n\n  blob () {\n    const ct = this.headers && this.headers.get('content-type') || ''\n    return this[CONSUME_BODY]().then(buf => Object.assign(\n      new Blob([], { type: ct.toLowerCase() }),\n      { [BUFFER]: buf }\n    ))\n  }\n\n  json () {\n    return this[CONSUME_BODY]().then(buf => {\n      try {\n        return JSON.parse(buf.toString())\n      } catch (er) {\n        return Promise.reject(new FetchError(\n          `invalid json response body at ${\n            this.url} reason: ${er.message}`, 'invalid-json'))\n      }\n    })\n  }\n\n  text () {\n    return this[CONSUME_BODY]().then(buf => buf.toString())\n  }\n\n  buffer () {\n    return this[CONSUME_BODY]()\n  }\n\n  textConverted () {\n    return this[CONSUME_BODY]().then(buf => convertBody(buf, this.headers))\n  }\n\n  [CONSUME_BODY] () {\n    if (this[INTERNALS].disturbed)\n      return Promise.reject(new TypeError(`body used already for: ${\n        this.url}`))\n\n    this[INTERNALS].disturbed = true\n\n    if (this[INTERNALS].error)\n      return Promise.reject(this[INTERNALS].error)\n\n    // body is null\n    if (this.body === null) {\n      return Promise.resolve(Buffer.alloc(0))\n    }\n\n    if (Buffer.isBuffer(this.body))\n      return Promise.resolve(this.body)\n\n    const upstream = isBlob(this.body) ? this.body.stream() : this.body\n\n    /* istanbul ignore if: should never happen */\n    if (!Minipass.isStream(upstream))\n      return Promise.resolve(Buffer.alloc(0))\n\n    const stream = this.size && upstream instanceof MinipassSized ? upstream\n      : !this.size && upstream instanceof Minipass &&\n        !(upstream instanceof MinipassSized) ? upstream\n      : this.size ? new MinipassSized({ size: this.size })\n      : new Minipass()\n\n    // allow timeout on slow response body\n    const resTimeout = this.timeout ? setTimeout(() => {\n      stream.emit('error', new FetchError(\n        `Response timeout while trying to fetch ${\n          this.url} (over ${this.timeout}ms)`, 'body-timeout'))\n    }, this.timeout) : null\n\n    // do not keep the process open just for this timeout, even\n    // though we expect it'll get cleared eventually.\n    if (resTimeout) {\n      resTimeout.unref()\n    }\n\n    // do the pipe in the promise, because the pipe() can send too much\n    // data through right away and upset the MP Sized object\n    return new Promise((resolve, reject) => {\n      // if the stream is some other kind of stream, then pipe through a MP\n      // so we can collect it more easily.\n      if (stream !== upstream) {\n        upstream.on('error', er => stream.emit('error', er))\n        upstream.pipe(stream)\n      }\n      resolve()\n    }).then(() => stream.concat()).then(buf => {\n      clearTimeout(resTimeout)\n      return buf\n    }).catch(er => {\n      clearTimeout(resTimeout)\n      // request was aborted, reject with this Error\n      if (er.name === 'AbortError' || er.name === 'FetchError')\n        throw er\n      else if (er.name === 'RangeError')\n        throw new FetchError(`Could not create Buffer from response body for ${\n          this.url}: ${er.message}`, 'system', er)\n      else\n        // other errors, such as incorrect content-encoding or content-length\n        throw new FetchError(`Invalid response body while trying to fetch ${\n          this.url}: ${er.message}`, 'system', er)\n    })\n  }\n\n  static clone (instance) {\n    if (instance.bodyUsed)\n      throw new Error('cannot clone body after it is used')\n\n    const body = instance.body\n\n    // check that body is a stream and not form-data object\n    // NB: can't clone the form-data object without having it as a dependency\n    if (Minipass.isStream(body) && typeof body.getBoundary !== 'function') {\n      // create a dedicated tee stream so that we don't lose data\n      // potentially sitting in the body stream's buffer by writing it\n      // immediately to p1 and not having it for p2.\n      const tee = new Minipass()\n      const p1 = new Minipass()\n      const p2 = new Minipass()\n      tee.on('error', er => {\n        p1.emit('error', er)\n        p2.emit('error', er)\n      })\n      body.on('error', er => tee.emit('error', er))\n      tee.pipe(p1)\n      tee.pipe(p2)\n      body.pipe(tee)\n      // set instance body to one fork, return the other\n      instance[INTERNALS].body = p1\n      return p2\n    } else\n      return instance.body\n  }\n\n  static extractContentType (body) {\n    return body === null || body === undefined ? null\n      : typeof body === 'string' ? 'text/plain;charset=UTF-8'\n      : isURLSearchParams(body)\n        ? 'application/x-www-form-urlencoded;charset=UTF-8'\n      : isBlob(body) ? body.type || null\n      : Buffer.isBuffer(body) ? null\n      : Object.prototype.toString.call(body) === '[object ArrayBuffer]' ? null\n      : ArrayBuffer.isView(body) ? null\n      : typeof body.getBoundary === 'function'\n        ? `multipart/form-data;boundary=${body.getBoundary()}`\n      : Minipass.isStream(body) ? null\n      : 'text/plain;charset=UTF-8'\n  }\n\n  static getTotalBytes (instance) {\n    const {body} = instance\n    return (body === null || body === undefined) ? 0\n    : isBlob(body) ? body.size\n    : Buffer.isBuffer(body) ? body.length\n    : body && typeof body.getLengthSync === 'function' && (\n        // detect form data input from form-data module\n        body._lengthRetrievers &&\n        /* istanbul ignore next */ body._lengthRetrievers.length == 0 || // 1.x\n        body.hasKnownLength && body.hasKnownLength()) // 2.x\n      ? body.getLengthSync()\n    : null\n  }\n\n  static writeToStream (dest, instance) {\n    const {body} = instance\n\n    if (body === null || body === undefined)\n      dest.end()\n    else if (Buffer.isBuffer(body) || typeof body === 'string')\n      dest.end(body)\n    else {\n      // body is stream or blob\n      const stream = isBlob(body) ? body.stream() : body\n      stream.on('error', er => dest.emit('error', er)).pipe(dest)\n    }\n\n    return dest\n  }\n}\n\nObject.defineProperties(Body.prototype, {\n  body: { enumerable: true },\n  bodyUsed: { enumerable: true },\n  arrayBuffer: { enumerable: true },\n  blob: { enumerable: true },\n  json: { enumerable: true },\n  text: { enumerable: true }\n})\n\n\nconst isURLSearchParams = obj =>\n  // Duck-typing as a necessary condition.\n  (typeof obj !== 'object' ||\n    typeof obj.append !== 'function' ||\n    typeof obj.delete !== 'function' ||\n    typeof obj.get !== 'function' ||\n    typeof obj.getAll !== 'function' ||\n    typeof obj.has !== 'function' ||\n    typeof obj.set !== 'function') ? false\n  // Brand-checking and more duck-typing as optional condition.\n  : obj.constructor.name === 'URLSearchParams' ||\n    Object.prototype.toString.call(obj) === '[object URLSearchParams]' ||\n    typeof obj.sort === 'function'\n\nconst isBlob = obj =>\n  typeof obj === 'object' &&\n  typeof obj.arrayBuffer === 'function' &&\n  typeof obj.type === 'string' &&\n  typeof obj.stream === 'function' &&\n  typeof obj.constructor === 'function' &&\n  typeof obj.constructor.name === 'string' &&\n  /^(Blob|File)$/.test(obj.constructor.name) &&\n  /^(Blob|File)$/.test(obj[Symbol.toStringTag])\n\n\nconst convertBody = (buffer, headers) => {\n  /* istanbul ignore if */\n  if (typeof convert !== 'function')\n    throw new Error('The package `encoding` must be installed to use the textConverted() function')\n\n  const ct = headers && headers.get('content-type')\n  let charset = 'utf-8'\n  let res, str\n\n  // header\n  if (ct)\n    res = /charset=([^;]*)/i.exec(ct)\n\n  // no charset in content type, peek at response body for at most 1024 bytes\n  str = buffer.slice(0, 1024).toString()\n\n  // html5\n  if (!res && str)\n    res = /<meta.+?charset=(['\"])(.+?)\\1/i.exec(str)\n\n  // html4\n  if (!res && str) {\n    res = /<meta[\\s]+?http-equiv=(['\"])content-type\\1[\\s]+?content=(['\"])(.+?)\\2/i.exec(str)\n\n    if (!res) {\n      res = /<meta[\\s]+?content=(['\"])(.+?)\\1[\\s]+?http-equiv=(['\"])content-type\\3/i.exec(str)\n      if (res)\n        res.pop() // drop last quote\n    }\n\n    if (res)\n      res = /charset=(.*)/i.exec(res.pop())\n  }\n\n  // xml\n  if (!res && str)\n    res = /<\\?xml.+?encoding=(['\"])(.+?)\\1/i.exec(str)\n\n  // found charset\n  if (res) {\n    charset = res.pop()\n\n    // prevent decode issues when sites use incorrect encoding\n    // ref: https://hsivonen.fi/encoding-menu/\n    if (charset === 'gb2312' || charset === 'gbk')\n      charset = 'gb18030'\n  }\n\n  // turn raw buffers into a single utf-8 buffer\n  return convert(\n    buffer,\n    'UTF-8',\n    charset\n  ).toString()\n}\n\nmodule.exports = Body\n","\nconst Minipass = require('minipass')\nconst TYPE = Symbol('type')\nconst BUFFER = Symbol('buffer')\n\nclass Blob {\n  constructor (blobParts, options) {\n    this[TYPE] = ''\n\n    const buffers = []\n    let size = 0\n\n    if (blobParts) {\n      const a = blobParts\n      const length = Number(a.length)\n      for (let i = 0; i < length; i++) {\n        const element = a[i]\n        const buffer = element instanceof Buffer ? element\n          : ArrayBuffer.isView(element)\n            ? Buffer.from(element.buffer, element.byteOffset, element.byteLength)\n          : element instanceof ArrayBuffer ? Buffer.from(element)\n          : element instanceof Blob ? element[BUFFER]\n          : typeof element === 'string' ? Buffer.from(element)\n          : Buffer.from(String(element))\n        size += buffer.length\n        buffers.push(buffer)\n      }\n    }\n\n    this[BUFFER] = Buffer.concat(buffers, size)\n\n    const type = options && options.type !== undefined\n      && String(options.type).toLowerCase()\n    if (type && !/[^\\u0020-\\u007E]/.test(type)) {\n      this[TYPE] = type\n    }\n  }\n\n  get size () {\n    return this[BUFFER].length\n  }\n\n  get type () {\n    return this[TYPE]\n  }\n\n  text () {\n    return Promise.resolve(this[BUFFER].toString())\n  }\n\n  arrayBuffer () {\n    const buf = this[BUFFER]\n    const off = buf.byteOffset\n    const len = buf.byteLength\n    const ab = buf.buffer.slice(off, off + len)\n    return Promise.resolve(ab)\n  }\n\n  stream () {\n    return new Minipass().end(this[BUFFER])\n  }\n\n  slice (start, end, type) {\n    const size = this.size\n    const relativeStart = start === undefined ? 0\n      : start < 0 ? Math.max(size + start, 0)\n      : Math.min(start, size)\n    const relativeEnd = end === undefined ? size\n      : end < 0 ? Math.max(size + end, 0)\n      : Math.min(end, size)\n    const span = Math.max(relativeEnd - relativeStart, 0)\n\n    const buffer = this[BUFFER]\n    const slicedBuffer = buffer.slice(\n      relativeStart,\n      relativeStart + span\n    )\n    const blob = new Blob([], { type })\n    blob[BUFFER] = slicedBuffer\n    return blob\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'Blob'\n  }\n\n  static get BUFFER () {\n    return BUFFER\n  }\n}\n\nObject.defineProperties(Blob.prototype, {\n  size: { enumerable: true },\n  type: { enumerable: true },\n})\n\nmodule.exports = Blob\n","\nclass FetchError extends Error {\n  constructor (message, type, systemError) {\n    super(message)\n    this.code = 'FETCH_ERROR'\n\n    // pick up code, expected, path, ...\n    if (systemError)\n      Object.assign(this, systemError)\n\n    this.errno = this.code\n\n    // override anything the system error might've clobbered\n    this.type = this.code === 'EBADSIZE' && this.found > this.expect\n      ? 'max-size' : type\n    this.message = message\n    Error.captureStackTrace(this, this.constructor)\n  }\n\n  get name () {\n    return 'FetchError'\n  }\n\n  // don't allow name to be overwritten\n  set name (n) {}\n\n  get [Symbol.toStringTag] () {\n    return 'FetchError'\n  }\n}\nmodule.exports = FetchError\n","\nconst http = require('http')\nconst { STATUS_CODES } = http\n\nconst Headers = require('./headers.js')\nconst Body = require('./body.js')\nconst { clone, extractContentType } = Body\n\nconst INTERNALS = Symbol('Response internals')\n\nclass Response extends Body {\n  constructor (body = null, opts = {}) {\n    super(body, opts)\n\n    const status = opts.status || 200\n    const headers = new Headers(opts.headers)\n\n    if (body !== null && body !== undefined && !headers.has('Content-Type')) {\n      const contentType = extractContentType(body)\n      if (contentType)\n        headers.append('Content-Type', contentType)\n    }\n\n    this[INTERNALS] = {\n      url: opts.url,\n      status,\n      statusText: opts.statusText || STATUS_CODES[status],\n      headers,\n      counter: opts.counter,\n      trailer: Promise.resolve(opts.trailer || new Headers()),\n    }\n  }\n\n  get trailer () {\n    return this[INTERNALS].trailer\n  }\n\n  get url () {\n    return this[INTERNALS].url || ''\n  }\n\n  get status () {\n    return this[INTERNALS].status\n  }\n\n  get ok ()  {\n    return this[INTERNALS].status >= 200 && this[INTERNALS].status < 300\n  }\n\n  get redirected () {\n    return this[INTERNALS].counter > 0\n  }\n\n  get statusText () {\n    return this[INTERNALS].statusText\n  }\n\n  get headers () {\n    return this[INTERNALS].headers\n  }\n\n  clone () {\n    return new Response(clone(this), {\n      url: this.url,\n      status: this.status,\n      statusText: this.statusText,\n      headers: this.headers,\n      ok: this.ok,\n      redirected: this.redirected,\n      trailer: this.trailer,\n    })\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'Response'\n  }\n}\n\nmodule.exports = Response\n\nObject.defineProperties(Response.prototype, {\n  url: { enumerable: true },\n  status: { enumerable: true },\n  ok: { enumerable: true },\n  redirected: { enumerable: true },\n  statusText: { enumerable: true },\n  headers: { enumerable: true },\n  clone: { enumerable: true },\n})\n","\nconst invalidTokenRegex = /[^\\^_`a-zA-Z\\-0-9!#$%&'*+.|~]/\nconst invalidHeaderCharRegex = /[^\\t\\x20-\\x7e\\x80-\\xff]/\n\nconst validateName = name => {\n  name = `${name}`\n  if (invalidTokenRegex.test(name) || name === '')\n    throw new TypeError(`${name} is not a legal HTTP header name`)\n}\n\nconst validateValue = value => {\n  value = `${value}`\n  if (invalidHeaderCharRegex.test(value))\n    throw new TypeError(`${value} is not a legal HTTP header value`)\n}\n\nconst find = (map, name) => {\n  name = name.toLowerCase()\n  for (const key in map) {\n    if (key.toLowerCase() === name)\n      return key\n  }\n  return undefined\n}\n\nconst MAP = Symbol('map')\nclass Headers {\n  constructor (init = undefined) {\n    this[MAP] = Object.create(null)\n    if (init instanceof Headers) {\n      const rawHeaders = init.raw()\n      const headerNames = Object.keys(rawHeaders)\n      for (const headerName of headerNames) {\n        for (const value of rawHeaders[headerName]) {\n          this.append(headerName, value)\n        }\n      }\n      return\n    }\n\n    // no-op\n    if (init === undefined || init === null)\n      return\n\n    if (typeof init === 'object') {\n      const method = init[Symbol.iterator]\n      if (method !== null && method !== undefined) {\n        if (typeof method !== 'function')\n          throw new TypeError('Header pairs must be iterable')\n\n        // sequence<sequence<ByteString>>\n        // Note: per spec we have to first exhaust the lists then process them\n        const pairs = []\n        for (const pair of init) {\n          if (typeof pair !== 'object' ||\n              typeof pair[Symbol.iterator] !== 'function')\n            throw new TypeError('Each header pair must be iterable')\n          const arrPair = Array.from(pair)\n          if (arrPair.length !== 2)\n            throw new TypeError('Each header pair must be a name/value tuple')\n          pairs.push(arrPair)\n        }\n\n        for (const pair of pairs) {\n          this.append(pair[0], pair[1])\n        }\n      } else {\n        // record<ByteString, ByteString>\n        for (const key of Object.keys(init)) {\n          this.append(key, init[key])\n        }\n      }\n    } else\n      throw new TypeError('Provided initializer must be an object')\n  }\n\n  get (name) {\n    name = `${name}`\n    validateName(name)\n    const key = find(this[MAP], name)\n    if (key === undefined)\n      return null\n\n    return this[MAP][key].join(', ')\n  }\n\n  forEach (callback, thisArg = undefined) {\n    let pairs = getHeaders(this)\n    for (let i = 0; i < pairs.length; i++) {\n      const [name, value] = pairs[i]\n      callback.call(thisArg, value, name, this)\n      // refresh in case the callback added more headers\n      pairs = getHeaders(this)\n    }\n  }\n\n  set (name, value) {\n    name = `${name}`\n    value = `${value}`\n    validateName(name)\n    validateValue(value)\n    const key = find(this[MAP], name)\n    this[MAP][key !== undefined ? key : name] = [value]\n  }\n\n  append (name, value) {\n    name = `${name}`\n    value = `${value}`\n    validateName(name)\n    validateValue(value)\n    const key = find(this[MAP], name)\n    if (key !== undefined)\n      this[MAP][key].push(value)\n    else\n      this[MAP][name] = [value]\n  }\n\n  has (name) {\n    name = `${name}`\n    validateName(name)\n    return find(this[MAP], name) !== undefined\n  }\n\n  delete (name) {\n    name = `${name}`\n    validateName(name)\n    const key = find(this[MAP], name)\n    if (key !== undefined)\n      delete this[MAP][key]\n  }\n\n  raw () {\n    return this[MAP]\n  }\n\n  keys () {\n    return new HeadersIterator(this, 'key')\n  }\n\n  values () {\n    return new HeadersIterator(this, 'value')\n  }\n\n  [Symbol.iterator]() {\n    return new HeadersIterator(this, 'key+value')\n  }\n\n  entries () {\n    return new HeadersIterator(this, 'key+value')\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'Headers'\n  }\n\n  static exportNodeCompatibleHeaders (headers) {\n    const obj = Object.assign(Object.create(null), headers[MAP])\n\n    // http.request() only supports string as Host header. This hack makes\n    // specifying custom Host header possible.\n    const hostHeaderKey = find(headers[MAP], 'Host')\n    if (hostHeaderKey !== undefined)\n      obj[hostHeaderKey] = obj[hostHeaderKey][0]\n\n    return obj\n  }\n\n  static createHeadersLenient (obj) {\n    const headers = new Headers()\n    for (const name of Object.keys(obj)) {\n      if (invalidTokenRegex.test(name))\n        continue\n\n      if (Array.isArray(obj[name])) {\n        for (const val of obj[name]) {\n          if (invalidHeaderCharRegex.test(val))\n            continue\n\n          if (headers[MAP][name] === undefined)\n            headers[MAP][name] = [val]\n          else\n            headers[MAP][name].push(val)\n        }\n      } else if (!invalidHeaderCharRegex.test(obj[name]))\n        headers[MAP][name] = [obj[name]]\n    }\n    return headers\n  }\n}\n\nObject.defineProperties(Headers.prototype, {\n  get: { enumerable: true },\n  forEach: { enumerable: true },\n  set: { enumerable: true },\n  append: { enumerable: true },\n  has: { enumerable: true },\n  delete: { enumerable: true },\n  keys: { enumerable: true },\n  values: { enumerable: true },\n  entries: { enumerable: true },\n})\n\nconst getHeaders = (headers, kind = 'key+value') =>\n  Object.keys(headers[MAP]).sort().map(\n    kind === 'key' ? k => k.toLowerCase()\n    : kind === 'value' ? k => headers[MAP][k].join(', ')\n    : k => [k.toLowerCase(), headers[MAP][k].join(', ')]\n  )\n\nconst INTERNAL = Symbol('internal')\n\nclass HeadersIterator {\n  constructor (target, kind) {\n    this[INTERNAL] = {\n      target,\n      kind,\n      index: 0,\n    }\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'HeadersIterator'\n  }\n\n  next () {\n    /* istanbul ignore if: should be impossible */\n    if (!this || Object.getPrototypeOf(this) !== HeadersIterator.prototype)\n      throw new TypeError('Value of `this` is not a HeadersIterator')\n\n    const { target, kind, index } = this[INTERNAL]\n    const values = getHeaders(target, kind)\n    const len = values.length\n    if (index >= len) {\n      return {\n        value: undefined,\n        done: true,\n      }\n    }\n\n    this[INTERNAL].index++\n\n    return { value: values[index], done: false }\n  }\n}\n\n// manually extend because 'extends' requires a ctor\nObject.setPrototypeOf(HeadersIterator.prototype,\n  Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())))\n\nmodule.exports = Headers\n","\nconst Url = require('url')\nconst Minipass = require('minipass')\nconst Headers = require('./headers.js')\nconst { exportNodeCompatibleHeaders } = Headers\nconst Body = require('./body.js')\nconst { clone, extractContentType, getTotalBytes } = Body\n\nconst version = require('../package.json').version\nconst defaultUserAgent =\n  `minipass-fetch/${version} (+https://github.com/isaacs/minipass-fetch)`\n\nconst INTERNALS = Symbol('Request internals')\n\nconst { parse: parseUrl, format: formatUrl } = Url\n\nconst isRequest = input =>\n  typeof input === 'object' && typeof input[INTERNALS] === 'object'\n\nconst isAbortSignal = signal => {\n  const proto = (\n    signal\n    && typeof signal === 'object'\n    && Object.getPrototypeOf(signal)\n  )\n  return !!(proto && proto.constructor.name === 'AbortSignal')\n}\n\nclass Request extends Body {\n  constructor (input, init = {}) {\n    const parsedURL = isRequest(input) ? Url.parse(input.url)\n      : input && input.href ? Url.parse(input.href)\n      : Url.parse(`${input}`)\n\n    if (isRequest(input))\n      init = { ...input[INTERNALS], ...init }\n    else if (!input || typeof input === 'string')\n      input = {}\n\n    const method = (init.method || input.method || 'GET').toUpperCase()\n    const isGETHEAD = method === 'GET' || method === 'HEAD'\n\n    if ((init.body !== null && init.body !== undefined ||\n        isRequest(input) && input.body !== null) && isGETHEAD)\n      throw new TypeError('Request with GET/HEAD method cannot have body')\n\n    const inputBody = init.body !== null && init.body !== undefined ? init.body\n      : isRequest(input) && input.body !== null ? clone(input)\n      : null\n\n    super(inputBody, {\n      timeout: init.timeout || input.timeout || 0,\n      size: init.size || input.size || 0,\n    })\n\n    const headers = new Headers(init.headers || input.headers || {})\n\n    if (inputBody !== null && inputBody !== undefined &&\n        !headers.has('Content-Type')) {\n      const contentType = extractContentType(inputBody)\n      if (contentType)\n        headers.append('Content-Type', contentType)\n    }\n\n    const signal = 'signal' in init ? init.signal\n      : null\n\n    if (signal !== null && signal !== undefined && !isAbortSignal(signal))\n      throw new TypeError('Expected signal must be an instanceof AbortSignal')\n\n    // TLS specific options that are handled by node\n    const {\n      ca,\n      cert,\n      ciphers,\n      clientCertEngine,\n      crl,\n      dhparam,\n      ecdhCurve,\n      family,\n      honorCipherOrder,\n      key,\n      passphrase,\n      pfx,\n      rejectUnauthorized = process.env.NODE_TLS_REJECT_UNAUTHORIZED !== '0',\n      secureOptions,\n      secureProtocol,\n      servername,\n      sessionIdContext,\n    } = init\n\n    this[INTERNALS] = {\n      method,\n      redirect: init.redirect || input.redirect || 'follow',\n      headers,\n      parsedURL,\n      signal,\n      ca,\n      cert,\n      ciphers,\n      clientCertEngine,\n      crl,\n      dhparam,\n      ecdhCurve,\n      family,\n      honorCipherOrder,\n      key,\n      passphrase,\n      pfx,\n      rejectUnauthorized,\n      secureOptions,\n      secureProtocol,\n      servername,\n      sessionIdContext,\n    }\n\n    // node-fetch-only options\n    this.follow = init.follow !== undefined ? init.follow\n      : input.follow !== undefined ? input.follow\n      : 20\n    this.compress = init.compress !== undefined ? init.compress\n      : input.compress !== undefined ? input.compress\n      : true\n    this.counter = init.counter || input.counter || 0\n    this.agent = init.agent || input.agent\n  }\n\n  get method() {\n    return this[INTERNALS].method\n  }\n\n  get url() {\n    return formatUrl(this[INTERNALS].parsedURL)\n  }\n\n  get headers() {\n    return this[INTERNALS].headers\n  }\n\n  get redirect() {\n    return this[INTERNALS].redirect\n  }\n\n  get signal() {\n    return this[INTERNALS].signal\n  }\n\n  clone () {\n    return new Request(this)\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'Request'\n  }\n\n  static getNodeRequestOptions (request) {\n    const parsedURL = request[INTERNALS].parsedURL\n    const headers = new Headers(request[INTERNALS].headers)\n\n    // fetch step 1.3\n    if (!headers.has('Accept'))\n      headers.set('Accept', '*/*')\n\n    // Basic fetch\n    if (!parsedURL.protocol || !parsedURL.hostname)\n      throw new TypeError('Only absolute URLs are supported')\n\n    if (!/^https?:$/.test(parsedURL.protocol))\n      throw new TypeError('Only HTTP(S) protocols are supported')\n\n    if (request.signal &&\n        Minipass.isStream(request.body) &&\n        typeof request.body.destroy !== 'function') {\n      throw new Error(\n        'Cancellation of streamed requests with AbortSignal is not supported')\n    }\n\n    // HTTP-network-or-cache fetch steps 2.4-2.7\n    const contentLengthValue =\n      (request.body === null || request.body === undefined) &&\n        /^(POST|PUT)$/i.test(request.method) ? '0'\n      : request.body !== null && request.body !== undefined\n        ? getTotalBytes(request)\n      : null\n\n    if (contentLengthValue)\n      headers.set('Content-Length', contentLengthValue + '')\n\n    // HTTP-network-or-cache fetch step 2.11\n    if (!headers.has('User-Agent'))\n      headers.set('User-Agent', defaultUserAgent)\n\n    // HTTP-network-or-cache fetch step 2.15\n    if (request.compress && !headers.has('Accept-Encoding'))\n      headers.set('Accept-Encoding', 'gzip,deflate')\n\n    const agent = typeof request.agent === 'function'\n      ? request.agent(parsedURL)\n      : request.agent\n\n    if (!headers.has('Connection') && !agent)\n      headers.set('Connection', 'close')\n\n    // TLS specific options that are handled by node\n    const {\n      ca,\n      cert,\n      ciphers,\n      clientCertEngine,\n      crl,\n      dhparam,\n      ecdhCurve,\n      family,\n      honorCipherOrder,\n      key,\n      passphrase,\n      pfx,\n      rejectUnauthorized,\n      secureOptions,\n      secureProtocol,\n      servername,\n      sessionIdContext,\n    } = request[INTERNALS]\n\n    // HTTP-network fetch step 4.2\n    // chunked encoding is handled by Node.js\n\n    return {\n      ...parsedURL,\n      method: request.method,\n      headers: exportNodeCompatibleHeaders(headers),\n      agent,\n      ca,\n      cert,\n      ciphers,\n      clientCertEngine,\n      crl,\n      dhparam,\n      ecdhCurve,\n      family,\n      honorCipherOrder,\n      key,\n      passphrase,\n      pfx,\n      rejectUnauthorized,\n      secureOptions,\n      secureProtocol,\n      servername,\n      sessionIdContext,\n    }\n  }\n}\n\nmodule.exports = Request\n\nObject.defineProperties(Request.prototype, {\n  method: { enumerable: true },\n  url: { enumerable: true },\n  headers: { enumerable: true },\n  redirect: { enumerable: true },\n  clone: { enumerable: true },\n  signal: { enumerable: true },\n})\n","module.exports = {\n  \"_from\": \"minipass-fetch@^1.3.2\",\n  \"_id\": \"minipass-fetch@1.4.1\",\n  \"_inBundle\": false,\n  \"_integrity\": \"sha1-114AkdqsGw/9fp1BYp+v99DB8bY=\",\n  \"_location\": \"/minipass-fetch\",\n  \"_phantomChildren\": {},\n  \"_requested\": {\n    \"type\": \"range\",\n    \"registry\": true,\n    \"raw\": \"minipass-fetch@^1.3.2\",\n    \"name\": \"minipass-fetch\",\n    \"escapedName\": \"minipass-fetch\",\n    \"rawSpec\": \"^1.3.2\",\n    \"saveSpec\": null,\n    \"fetchSpec\": \"^1.3.2\"\n  },\n  \"_requiredBy\": [\n    \"/make-fetch-happen\"\n  ],\n  \"_resolved\": \"https://registry.npmmirror.com/minipass-fetch/download/minipass-fetch-1.4.1.tgz\",\n  \"_shasum\": \"d75e0091daac1b0ffd7e9d41629faff7d0c1f1b6\",\n  \"_spec\": \"minipass-fetch@^1.3.2\",\n  \"_where\": \"D:\\\\毕设小程序\\\\闲者集市\\\\proj\\\\node_modules\\\\make-fetch-happen\",\n  \"bugs\": {\n    \"url\": \"https://github.com/npm/minipass-fetch/issues\"\n  },\n  \"bundleDependencies\": false,\n  \"dependencies\": {\n    \"encoding\": \"^0.1.12\",\n    \"minipass\": \"^3.1.0\",\n    \"minipass-sized\": \"^1.0.3\",\n    \"minizlib\": \"^2.0.0\"\n  },\n  \"deprecated\": false,\n  \"description\": \"An implementation of window.fetch in Node.js using Minipass streams\",\n  \"devDependencies\": {\n    \"@ungap/url-search-params\": \"^0.1.2\",\n    \"abort-controller\": \"^3.0.0\",\n    \"abortcontroller-polyfill\": \"~1.3.0\",\n    \"form-data\": \"^2.5.1\",\n    \"parted\": \"^0.1.1\",\n    \"string-to-arraybuffer\": \"^1.0.2\",\n    \"tap\": \"^15.0.9\",\n    \"whatwg-url\": \"^7.0.0\"\n  },\n  \"engines\": {\n    \"node\": \">=8\"\n  },\n  \"files\": [\n    \"index.js\",\n    \"lib/*.js\"\n  ],\n  \"homepage\": \"https://github.com/npm/minipass-fetch#readme\",\n  \"keywords\": [\n    \"fetch\",\n    \"minipass\",\n    \"node-fetch\",\n    \"window.fetch\"\n  ],\n  \"license\": \"MIT\",\n  \"main\": \"lib/index.js\",\n  \"name\": \"minipass-fetch\",\n  \"optionalDependencies\": {\n    \"encoding\": \"^0.1.12\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/npm/minipass-fetch.git\"\n  },\n  \"scripts\": {\n    \"postpublish\": \"git push origin --follow-tags\",\n    \"postversion\": \"npm publish\",\n    \"preversion\": \"npm test\",\n    \"snap\": \"tap\",\n    \"test\": \"tap\"\n  },\n  \"tap\": {\n    \"coverage-map\": \"map.js\",\n    \"check-coverage\": true\n  },\n  \"version\": \"1.4.1\"\n}\n","\nclass AbortError extends Error {\n  constructor (message) {\n    super(message)\n    this.code = 'FETCH_ABORTED'\n    this.type = 'aborted'\n    Error.captureStackTrace(this, this.constructor)\n  }\n\n  get name () {\n    return 'AbortError'\n  }\n\n  // don't allow name to be overridden, but don't throw either\n  set name (s) {}\n}\nmodule.exports = AbortError\n"]}